// Example 1: builtins for a simple run.

def __pos__(x: {T: Numeric}) : T =>
$$pyinline
+${x}
$$end

def __neg__(x: {T: Numeric}) : T =>
$$pyinline
-${x}
$$end

def __inv__(x: Int) : Int =>
$$pyinline
~${x}
$$end

def __not__(x: Bool) : Bool =>
$$pyinline
not ${x}
$$end

def __if__(cond: Bool, val_true: {T : Any}, val_false: T) : T =>
$$pyinline
(${val_true} if ${cond} else ${val_false})
$$end

def __between__(val: {T}, min_val: T, max_val: T) : Bool =>
$$pyinline
(${min_val} <= ${val} <= ${max_val})
$$end

def __mul__(x: {T: Numeric}, y: T) : T =>
$$pyinline
${x} * ${y}
$$end

def __div__(x: {T: Numeric}, y: T) : T =>
$$pyinline
${x} / ${y}
$$end

def __mod__(x: {T: Numeric}, y: T) : T =>
$$pyinline
${x} % ${y}
$$end

def __add__(x: {T: Numeric}, y: T) : T =>
$$pyinline
${x} + ${y}
$$end

def __sub__(x: {T: Numeric}, y: T) : T =>
$$pyinline
${x} - ${y}
$$end

def __sub__(x: {T: Union<Date, DateTime>}, y: T) : TimeInterval =>
$$pyinline
${x} - ${y}
$$end

def __rshift__(x: {T:Integral}, y: UInt) : T =>
$$pyinline
${x} >> ${y}
$$end

def __lshift__(x: {T:Integral}, y: UInt) : T =>
$$pyinline
${x} << ${y}
$$end

typedef Sortable = Union<String, Bytes, Numeric,
                         Date, DateTime, Timestamp, TimeInterval>

def __lt__(x: {T: Sortable}, y: T) : Bool =>
$$pyinline
${x} < ${y}
$$end

def __le__(x: {T: Sortable}, y: T) : Bool =>
$$pyinline
${x} <= ${y}
$$end

def __eq__(x: {T: Sortable}, y: T) : Bool =>
$$pyinline
${x} == ${y}
$$end

def __ne__(x: {T: Sortable}, y: T) : Bool =>
$$pyinline
${x} != ${y}
$$end

def __gt__(x: {T: Sortable}, y: T) : Bool =>
$$pyinline
${x} < ${y}
$$end

def __ge__(x: {T: Sortable}, y: T) : Bool =>
$$pyinline
${x} <= ${y}
$$end

def __bit_and__(x: Int, y: Int) : Int =>
$$pyinline
${x} & ${y}
$$end

def __bit_or__(x: Int, y: Int) : Int =>
$$pyinline
${x} | ${y}
$$end

def __bit_xor__(x: Int, y: Int) : Int =>
$$pyinline
${x} ^ ${y}
$$end

def __and__(x: Bool, y: Bool) : Bool =>
$$pyinline
${x} and ${y}
$$end

def __or__(x: Bool, y: Bool) : Bool =>
$$pyinline
${x} or ${y}
$$end

def __xor__(x: Bool, y: Bool) : Bool =>
$$pyinline
${x} != ${y}
$$end

def is_null(x: Nullable<{T:Any}>) : Bool =>
$$pyinline
${x} is None
$$end

def _ensured(x: Nullable<{T:Any}>) : T =>
$$pyinline
${x}
$$end

def ensure(x: Nullable<{T:Int}>, val: Int = 0) : Int =>
  is_null(x) ? (val, _ensured(x))

def ensure(x: Nullable<{T:UInt}>, val: UInt = 0u) : UInt  =>
  is_null(x) ? (val, _ensured(x))

def ensure(x: Nullable<String>, val: String = "") : String  =>
  is_null(x) ? (val, _ensured(x))

def ensure(x: Nullable<Bytes>, val: Bytes = b"") : Bytes  =>
  is_null(x) ? (val, _ensured(x))

def ensure(x: Nullable<Bool>, val: Bool = false) : Bool  =>
  is_null(x) ? (val, _ensured(x))

def method ensured_run(x: Nullable<{X}>,
  f: Function<X, Nullable<{Y}>>) : Nullable<Y> =>
// Normal implementation - need to sort out calling non-function
//  named objects is_null(x) ? (null, f(_ensured(x)))
$$pyinline
nudl.ensured_run(${x} ${f})
$$end

def method concat(x: Iterable<String>, joiner: String) : String =>
$$pyinline
${joiner}.join(${x})
$$end

// Different len method, as we want to get in the proper store
def method len(l: {X: Union<Container<{Y}>, String, Bytes>}) : UInt =>
// May actually want to do something different for Iterable.
// as len(filter(...)) would not work.
$$pyinline
len(${l})
$$end

def method to_array(l: Iterable<{X: Any}>) : Array<X> =>
$$pyinline
list(${l})
$$end

def method map(
  l: Iterable<{X : Any}>,
  f: Function<X, {Y : Any}>) : Generator<Y> =>
$$pyinline
map(lambda x: ${f}(x), ${l})
$$end

def method sum(l: Iterable<{X : Numeric}>) : X =>
$$pyinline
sum(${l})
$$end

def method filter(
  l: Iterable<{X : Any}>,
  f: Function<X, Bool>) : Generator<X> =>
$$pyinline
[__x for __x in ${l} if ${f}(${l})]
$$end

def method aggregate_to_array(
  l: Iterable<{X : Any}>,
  key: Function<X, {Y: Any}>,
  value: Function<X, {Z: Any}>) : Generator<Tuple<Y, Array<Z>>> =>
$$pyinline
nudl.aggregate_to_array(${l}, ${key}, ${value})
$$end

def method aggregate_to_set(
  l: Iterable<{X : Any}>,
  key: Function<X, {Y: Any}>,
  value: Function<X, {Z: Any}>) : Generator<Tuple<Y, Set<Z>>> =>
$$pyinline
nudl.aggregate_to_set(${l}, ${key}, ${value})
$$end

def method sort(
  l: Array<{X : Any}>,
  sorter: Function<X, X, Bool>) : Array<X> =>
$$pyinline
nudl.sort_stable(${l}, ${sorter})
$$end

def method front(
  l: Array<{X: Any}>) : Nullable<X> =>
$$pyinline
${l}[0] if ${l} else None
$$end

def method front(
  l: Generator<{X: Any}>) : Nullable<X> =>
$$pyimport
import itertools
$$end
$$pyinline
nudl.front(list(itertools.slice(${l}, 1)))
$$end

def method shuffle(
  l: Array<{X: Any}>) : Array<X> =>
$$pyimport
nudl.shuffle(l)
$$end


def method max(l: Iterable<{X: Sortable}>) : X =>
$$pyinline
max(${l})
$$end

def method min(l: Array<{X: Sortable}>) : X =>
$$pyinline
min(${l})
$$end

def method max_by(
  l: Iterable<{X}>,
  f: Function<X, {Y: Sortable}>): Nullable<X> =>
$$pyinline
min(map(lambda e: (${f}(e), e), l))[1]
$$end

def method min_by(
  l: Iterable<{X}>,
  f: Function<X, {Y: Sortable}>) : Nullable<X> =>
$$pyinline
min(map(lambda e: (${f}(e), e), l))[1]
$$end

def method empty(
  l: Container<{X: Any}>) : Bool =>
$$pyinline
nudl.empty({l})
$$end

def method empty(
  l: Generator<{X: Any}>) : Bool =>
$$pyimport
import itertools
$$end
$$pyinline
len(list(itertools.slice(${l}, 1))) == 0
$$end

typedef Hashable = Union<Numeric, String, Bytes, Bool, Decimal,
                         Date, TimeInterval, Timestamp, DateTime>

////////////////////////////////////////////////////////////////////////////////
//
// Default values for basic types:
//
def constructor int() : Int => 0
def constructor int8() : Int8 => 0
def constructor int16() : Int16 => 0
def constructor int32() : Int32 => 0
def constructor uint() : UInt => 0u
def constructor uint8() : UInt8 => 0u
def constructor uint16() : UInt16 => 0u
def constructor uint32() : UInt32 => 0u
def constructor string() : String => ""
def constructor bytes() : Bytes => b""
def constructor bool() : Bool => false
def constructor array(t: {T}) : Array<T> => []
def constructor set(t: {T}) : Set<T> => []
def constructor dict(k: {K : Hashable}, v: {V}) : Map<K, V> => []
def constructor nullable(t: {T}) : Nullable<T> => null


def constructor int(x: Union<Numeric, Bool>) : Int =>
$$pyinline
int(${x})
$$end

def constructor int(x: String, default: Int) : Int =>
$$pyinline
nudl.to_int(${x}, default)
$$end

// Returns null on invalid string representation:
def constructor int(x: String) : Nullable<Int> =>
$$pyinline
nudl.to_int(${x})
$$end

def constructor bool(v: Union<Numeric, String, Bytes>): Bool =>
$$pyinline
nudl.to_int(${v})
$$end

// We need a typedef :)
def constructor bool(value: Nullable<Union<Numeric, String, Bytes>>) : Bool => {
    // TODO(catalin): Interesting fact - if I use this:
    //    is_null(value) ? (false, bool(_ensured(value)))
    // I find for that bool first myself.. need to use:
    is_null(value) ? (false, Bool(_ensured(value)))
}

def constructor timestamp() : Timestamp =>
$$pyinline
nudl.timestamp_now()
$$end

def constructor timestamp(utc_timestamp_ms: Int) : Timestamp =>
$$pyinline
nudl.timestamp(${utc_timestamp_ms})
$$end

def constructor date() : Date =>
// To detemine in which timezone this happens - may need a parameter
$$pyinline
nudl.date_today()
$$end

def constructor datetime() : DateTime =>
// To detemine in which timezone this happens - may need a parameter
$$pyinline
nudl.datetime_now()
$$end

def constructor date(year: Int, month: Int, day: Int) : Nullable<Date> =>
$$pyinline
nudl.date_safe(${year}, ${month}, ${day})
$$end

def method year(date: Date) : Int =>
$$pyinline
${date}.year
$$end

def method month(date: Date) : Int =>
$$pyinline
${date}.month
$$end

def method day(date: Date) : Int =>
$$pyinline
${date}.day
$$end

def constructor date(ts: Timestamp) : Date =>
$$pyinline
nudl.date_from_timestamp(${ts})
$$end

def constructor date_time(year: Int, month: Int, day: Int,
  hour: Int = 0, minute: Int = 0, second: Int = 0) : Nullable<DateTime> =>
$$pyinline
nudl.datetime_safe(${year}, ${month}, ${day}, ${hour}, ${minute}, ${second})
$$end

def constructor date_time(ts: Timestamp) : DateTime =>
$$pyinline
nudl.datetime_from_timestamp(${ts})
$$end

def constructor to_string(x: Numeric) : String =>
$$pyinline
str(${x})
$$end
